1. 컴퓨터 알고리즘이란?
	> 문제를 해결하거나 함수를 계산하기 위해 모호함이 없는 간단한 명령들로 구성된 일련의 순서적 단계를 말합니다.


2. 알고리즘이 만족해야 할 조건
	> 0개 이상 입력되어야 하고, 1개 이상 출력되어야 합니다.
	> 단순하고 모호함이 없어야 합니다.
	> 한정 단계 후에는 종료되어야 합니다.
	> 명령들은 실행 가능해야 합니다.

3. 알고리즘 성능 분석
	1) 공간 복잡도
		프로그램이 실행될 때 사용되는 메모리 공간의 크기를 말함.
		사용되는 공간이 적을수록 공간 복잡도가 좋음.
	2) 시간 복잡도
		프로그램이 실행되는 시간을 뜻함.
		동일 입/출력일 때, 실행되는 시간이 짧을수록 시간 복잡도가 좋음.

4. 시간 복잡도 측정 방법?(Big-O 표기도 같이)
	1) 프로그램이 실행되는 실제 시간을 측정(이 방법은 컴퓨터 성능마다 다르게 나올 수 있음.)
	2) 실행되는 알고리즘의 연산 개수를 측정(일반적인 측정법)
	-> Big-O 표기법(해당 알고리즘에서 최악의 경우 n을 계산.)

5. 하향식 접근 방법과 상향식 접근 방법
	1) 하향식 접근 방법
	큰 문제를 작은 단위로 나눠 작은 문제들부터 해결하는 방식.
	작은 단위로 나눠진 문제들은 독립적이다.
	2) 상향식 접근 방법
	작은 문제들의 해를 구하고 그 해를 이용하여 더 큰 문제의 해를 구하는 방식.
	작은 문제들은 독립적이지 않으며 연관되어 있다.

6. 분할 정복(특징과 단계까지)
	> 하향식 접근 방법
	> 분할된 작은 문제는 입력 크기만 작아지고 원 문제와 동일하다.
	> 단계
		1) 분할
		큰 문제를 작은 문제들로 나눈다.
		2) 정복
		나뉜 작은 문제들의 해를 구한다.
		3) 결합
		작은 문제들의 해를 이용하여 보다 더 큰 문제의 해를 구한다.

7. 동적 프로그래밍
	> 상향식 접근 방법

8. 욕심쟁이(greedy) 방법
	> 해당 단계에서의 최적해를 구하는 방법( -> 전체적인 최적해는 구하지 못할 수 있다.)

9. 각 알고리즘끼리의 차이점(분할과 동적, 동적과 욕심쟁이)
	> 분할 정복과 동적 프로그래밍은 각각 하향식 접근 방법, 상향식 접근 방법이라는 것이 차이점.
	> 동적 프로그래밍은 상향식 접근 방법으로 전체적인 최적해를 구할 수 있지만, 욕심쟁이(greedy) 방법은
	각 단계에서의 최적해를 구하기 때문에 전체적인 최적해를 구하지 못할 수 있다.

10. 재귀함수?
	> 자기 자신을 호출하는 함수로, 재귀함수 안에는 종료 조건과 호출 조건이 존재해야 한다.

11. 제자리 알고리즘, 안정적/불안정적 알고리즘?
	1) 제자리 알고리즘
	해당 알고리즘에서 추가적인 공간을 쓰는가?
	2) 안정적/불안정적 알고리즘
	안정적 알고리즘은 해당 알고리즘에서 위치값이 정해지면 바뀌지 않는 것이고, 불안정적 알고리즘은
	위치값이 정해진 후에도 해당 값이 위치가 바뀔 수 있으면 불안정적 알고리즘이라 한다.

12. 정렬 Sort 개념
	> 데이터를 일정한 규칙에 따라 재배열하는 것을 말한다.(오름차순 또는 내림차순으로)

13. 버블 정렬
	> 배열의 인접한 두 값들끼리 비교하는 알고리즘.
	> 한 번 정렬될 때마다 마지막 원소의 값이 결정된다.
	> 안정적 알고리즘, 제자리 알고리즘
	> 최악의 경우 O(n의 2승)

14. 삽입 정렬
	> 미정렬 부분의 첫 번째 원소로부터 정렬된 부분의 제자리에 삽입
	> 안정적 알고리즘, 제자리 알고리즘
	> 최악의 경우 O(n의 2승)

15. 선택 정렬
	> 미정렬 데이터에서 가장 작은 값(혹은 가장 큰 값)을 선택하여 미정렬 데이터의 첫 번째 원소와 자리를 바꾸는 알고리즘.
	> 안정적/불안정적 알고리즘(한 번 위치가 정해진 후에도 위치가 바뀔 수도 있기 때문에.), 제자리 알고리즘
	> 최악의 경우 O(n의 2승)

16. 버블, 삽입, 선택 정렬의 비교와 자리 교환 횟수
	> 버블 정렬 비교 횟수 많음, 자리 교환 횟수 많음
	> 삽입 정렬 비교 횟수 덜함, 자리 교환 횟수 덜함
	> 선택 정렬 비교 횟수 덜함, 자리 교환 횟수 조금

17. 병합/합병 정렬(Merge Sort, 재귀함수 호출방법도 쓰기)
	> 배열을 두 개로 쪼개어 정렬하고, 다시 병합하는 작업 반복
	> 분할 정복 방식.(큰 문제를 작은 문제로 나눠 해결.)
	> 안정적 알고리즘
	> 제자리 알고리즘X(주어진 공간 외에 추가적인 공간을 사용함.)
	> 재귀함수 호출 방법
		변수 : left(왼쪽인덱스), right(오른쪽 인덱스), mid(중간인덱스)
		if(start < end) 일 때 재귀함수 사용
		함수(arg, left, mid);
		함수(arg, mid + 1, right);
		병합함수(arg, left, mid + 1, right);

18. 퀵 정렬(재귀함수 호출방법도 쓰기)
	> 적절한 원소를 정하여(pivot값) 그 값을 기준으로 작은 것과 큰 것으로 나눔.
	> 나눈 것에서 다시 기준을 잡고 나눔(각 크기가 1이 될 때까지 분할하기)
	> 분할 정복 방법
	> 안정적 알고리즘(기준값 pivot은 위치가 한 번 정해지면 바뀌지 않음)
	> 제자리 알고리즘
	> 재귀함수 호출 방법
		if(left <= right) 일 때 재귀함수 사용
		pivot값 정하기
		함수(arg, left, pivot - 1);
		함수(arg, pivot + 1, right);
		-> 피봇값 기준 왼쪽과 오른쪽 영역으로 나눔.
		
19. 각 정렬의 Big-O 표기값 쓰기(최악의 경우, 평균적인 값)
	> 일반 정렬
	버블 정렬, 삽입 정렬, 선택 정렬
	최악의 경우와 평균적인 경우 둘 다 O(n의 2승)

	> 병합/합병 정렬
	최악의 경우와 평균적인 경우 둘 다 nlog(n)

	> 퀵 정렬
	최악의 경우 n의 2승, 평균적인 경우 nlog(n)

	> 힙 정렬
	최악의 경우와 평균적인 경우 둘 다 nlog(n)


20. 순차(선형) 검색
	> 정렬되어 있지 않은 데이터에서 검색
	> 첫 번째 ~ 마지막 원소를 순서대로 돌면서 값을 찾는다.
	> 최악의 경우 O(n)

21. 이진(이분) 검색
	> 정렬된 데이터에서 검색
	> 배열의 중간 위치를 잡고 키값을 크기 비교하여 왼쪽이나 오른쪽으로 검색 방향 결정.
	> 평균 탐색 시간 O(logn)



































