<2022.06.03일자 공부 기록>

1. 영단어 복습
	dictate(받아쓰게 하다, 지시하다), dictionary(사전), predict(예측하다, 전망하다), contradict(모순되다, 반박하다), addict(중독되게 하다, 빠지게 하다),
	verdict(배심원의 평결, 결정), dedicate(헌신하다, 바치다, 전념하다), indicate(가리키다, 지적하다, 나타내다), doctor(의사, 박사, 선생),
	doctrine(원칙, 교리, 가르침), document(문서, 파일), essence(본질, 가장 중요한 것, 정수), present(현재의, 오늘날의, 참석한), represent(대표하다, 나타내다),
	absent(없는, 결석한), esteem(존경하다, 평가하다, 생각하다), estimate(평가하다, 추정하다, 판단하다), overestimate(과대평가하다, 높이 쳐주다),
	underestimate(과소평가하다, 깔보다), fable(우화, 꾸며낸 이야기), fame(명성, 유명세), fate(운명, 숙명), fairy(요정), infant(유아, 젖먹이), preface(서문, 머리말),
	confess(자백하다, 인정하다), professional(직업의, 전문적인), fallacy(오류, 틀린 생각), false(틀린, 사실이 아닌, 가짜의), fail(실패하다, 낙제하다),
	fault(잘못, 책임, 단점, 결함), fare(가다, 지내다, (교통)요금), farewell(작별인사), welfare(행복, 복지), defend(방어하다, 수비하다, 옹호하다),	
	fence(울타리, 장애물), offend(기분 상하게 하다, 위반하다), festival(축제, 기념제), feast(연회, 잔치, 축제), confident(확신하는, 자신감 있는), fidelity(충실함, 신의),
	federal(연방제의, 연방 정부의), faith(믿음, 신뢰, 신앙), defy(반항하다, 얕보다), filament(필라멘트, 가는 실), file(파일, 서류철), profile(옆얼굴, 개요, 윤곽선),
	fine(질 높은, 좋은, 괜찮은, 섬세한), final(마지막의, 최종의), finance(재원, 재정, 자금), finish(끝내다, 마치다), refine(정제하다, 개선하다),
	confine(국한하다, 넣다, 가두다), define(정의하다, 분명히 밝히다)


2. 학교 공부 필기
	<알고리즘>
	- 동적 프로그래밍&욕심쟁이 방법
		> 최적화 문제 해결에 주로 사용
		> 최적성의 원리가 적용된 방법

	- 탐욕 알고리즘
		> 최적화 문제의 답을 얻기 위해 사용
		> 동적 계획법처럼 반드시 최적의 해를 구해준다는 보장은 하지 못한다.(동적 프로그래밍과의 차이점)

	- 최소 신장 트리
		> 간선에 가중치 속성 부여, 각 간선이 갖고 있는 가중치의 합이 최소가 되는 신장 트리가 바로
		최소 신장 트리가 된다.

	- 프림 알고리즘과 크루스칼 알고리즘의 차이점
		> 프림 알고리즘은 시작점이 있어야 함, 크루스칼 알고리즘은 시작점이 없어도 됨.
		+) 다익스트라 알고리즘은 시작, 도착점 모두 있어야 함.

	- 프림 알고리즘 과정
		> 처음 시작점에서 간선 가중치가 가장 낮은 간선을 찾는다.(최소 신장 트리로 표현)
		(시작점에서부터 가중치 낮은 순으로 천천히 확장한다는 느낌으로 보면 됨)
		> 그 다음 현재 상태에서 간선 가중치가 낮은 곳을 찾아 최소 신장 트리로 표현한다.
		> 그렇게 계속 현재 연결된 노드들을 기준으로 가중치가 가장 낮은 노드를 찾아 연결하면 된다.

	- 크루스칼 알고리즘
		> 그래프 내의 모든 간선을 가중치의 오름차순으로 목록을 만든다.
		> 위에서 만든 목록을 차례대로 순회하며 간선을 최소 신장 트리에 추가, 이때 추가된 간선으로
		최소 신장 트리 내에 사이클이 형성되면 안 됨.

	- 다익스트라 알고리즘(최단 경로 탐색)
		> 그래프 내의 한 정점에서 다른 정점으로 이동할 때 가중치 합이 최소값이 되도록 만드는 경로를
		찾는 알고리즘
		> 도착점까지의 거리를 욕심쟁이 방법으로 해당 위치에서 가중치가 가장 낮은 간선을 선택하여 경로를
		연결한다.
		> 위에서 욕심쟁이 방법으로 찾은 경로가 최적의 경로인지 다른 경로로 연결해 본 후 값을 비교하여
		최적의 경로를 찾는 과정을 거친다.
		(요약하자면, 처음 경로를 찾을 때에는 욕심쟁이 방법으로 찾은 후 다른 경로로도 찾아서 값을 비교하여
		마지막에는 최적의 경로가 나오도록 하는 것이다.)

	- 프림/크루스칼 알고리즘은 동적 프로그래밍 방법, 다익스트라 알고리즘은 욕심쟁이 방법에 해당된다.

	- 그래프의 4가지 종류, 그래프->트리로 바꾸는 알고리즘 5가지 종류
	(ex : 깊이우선, 너비우선 알고리즘은 방향/가중치가 없는 그래프를 트리로 바꾸는 데 사용, 가중치가 있는 그래프들은 위의 3가지 알고리즘 사용)
	(ex : 방향과 가중치가 모두 있는 그래프는 다익스트라 알고리즘을 사용한다.)
	=> 그래프의 종류를 보고 어떤 알고리즘을 사용하여 트리로 바꿀지 생각하기


	<운영체제>
	- 조건문 문법
		if [ 조건 ]
		then
			참인 경우 처리문
		else
			거짓인 경우 처리문
		fi

	- case문 문법
		case 변수(값) in
		값1)
			처리문1
		값2)
			처리문2
		......
		*)
			위 경우 이외의 모든 경우 처리문
		esac

	- 예시
		#! /bin/sh
		kor=$1
		eng=$2
		mat=$3
		ave=`expr \( $kor + $eng + $mat \) / 3`
		pk=`expr $ave / 10`

		case $pk in
			9)
				echo "A학점";;
			8)
				echo "B학점";;
			7)
				echo "C학점";;
			6)
				echo "D학점";;
			*)
				echo "F학점";;
		esac

		-> 입력받은 성적을 평균을 구한 후 case문을 통해 학점을 출력하는 예제이다.

	- 반복문(for) 문법
		> 기본 문법
		for 변수 in 값1 값2 값3.....
		do
			반복할 문장
		done

		> 위에 in 뒤에 값1 값2 값3..... 이렇게 쓰지 않고 연속되는 숫자일 경우
		$(seq 숫자) 형식으로 사용해도 된다.
		ex)
		for i in $(seq 10)
		-> 1부터 10까지 숫자가 i값에 들어가며 반복문을 돈다.

		> $(seq ~) 문법 대신 리스트 형식을 활용해도 된다.
		ex)
		list="1 2 3 4 5"
		for i in $list
		-> 리스트에 있는 1~5의 값들이 순차적으로 i 변수에 들어가며 반복문을 돈다.

		> 예제(파일 내용 출력)
		for fname in $(ls *.sh)
		do
			head -3 $fname
		done
		-> 현재 디렉터리에 있는 쉘 스크립트 파일(*.sh)의 이름과 앞 세 행을 출력

	- 반복문(while) 문법
		> 기본 문법
		while [ 조건 ]
		do
			처리문
		done

		> 예제
		while [ 1 ]
		do
			echo "리눅스 우분투"
		done
		exit 0
		-> 이 예제는 무한루프를 돌게 됨

	- 문제 : while문을 이용하여 파라메타 값까지 짝수의 합과 홀수의 합을 출력하세요
	(시험문제 나올 가능성 높음!)
	
	- while 예제
		echo "비밀번호를 입력하세요."
		read mypass
		while [$mypass != "1234" ]
		do
			echo "틀렸음, 다시 입력하세요."
			read mypass
		done
		echo "통과"
		exit 0
		-> 위 예제에서 count 변수를 만들어 비밀번호를 몇 회 틀렸는지 횟수 세기

	- break : 반복문 종료
	- continue : 반복문의 조건식으로 돌아감
	- exit : 프로그램을 완전 종료
	- return : 함수를 호출한 곳으로 돌아가게 함

