<2022.06.16일자 공부 기록>

1. 학교 시험 대비(운영체제)
	- 리눅스 기본 명령어
	> ls : 해당 경로의 내용(디렉터리, 파일) 검색
	> cd : 경로 이동
	> pwd : 현재 위치의 경로값 보여줌
	> touch : 크기가 0인 파일 생성
	> mkdir : 디렉터리 생성
	> rmdir : 빈 디렉터리 삭제(디렉터리 안에 내용이 있으면 삭제X)
	> cp : 파일 복사
	> rm : 파일/디렉터리 삭제
	(옵션 r 사용 시 디렉터리 안에 내용이 있어도 삭제, 옵션 i는 삭제할 때 물어봄, 옵션 f 사용 시 확인하지 않고 바로 삭제)
	> mv : 파일 옮김
	> cat : 파일 내용 출력
	> head : 파일 내용을 위에서부터 10줄(기본값) 출력
	> tail : 파일 내용을 아래에서부터 10줄(기본값) 출력
	> more : 파일 내용을 페이지 단위로 화면에 출력
	> less : more 명령어와 비슷, 확장된 기능의 명령어
	> file : 해당 파일이 어떤 종류의 파일인지 보여줌
	> clear : 터미널 화면을 깨끗하게 해줌
	
	- 파일 압축 관련 명령어 -> xz, gzip, bzip2, zip

	- 파일 묶기
	> tar 명령어
	-c : 새로운 묶음 파일 만듦, -v : 압축한 내용 보여줌, -f : 파일 지정
	-J : xz 압축, -z : gz, -j : bzip2 압축

	- 파이프
	> 두 프로그램을 연결하는 연결 통로를 의미, | 기호로 사용

	- 필터
	> 필요한 것만 걸러주는 명령으로 grep, tail, wc, aort 등이 있다.(주로 파이프와 함께 사용)

	- 리디렉션
	> 표준 입출력의 방향을 바꿔주는 것.
	A > B : A 내용을 화면에 출력하지 않고 B 파일에 저장(기존 B 파일 존재시 덮어씀)
	A >> B : 위와 똑같이 B 파일에 내용을 저장하는데, 차이점은 B 파일이 존재하면 기존 내용에 이어 붙인다.
	sort < A : A의 내용을 정렬하여 화면에 출력함.

	- 사용자/그룹 관련 명령어
	> adduser : 새로운 사용자 추가
	> passwd : 사용자 비밀번호 변경
	> usermod : 사용자 속성 변경
	> chage : 사용자 비밀번호 주기적으로 변경하게 함
	> groups : 사용자가 소속된 그룹 보여줌
	> groupadd : 새로운 그룹 생성
	> groupmod : 그룹 속성 변경
	> groupdel : 그룹 삭제
	> gpasswd : 그룹 비밀번호 설정/그룹 관리

	- ls -l 명령어 실행 시 순서
	파일 유형(-면 파일, d면 디렉터리, b는 블록 디바이스, c는 문자 디바이스 등...), 파일 권한, 링크 수, 파일 소유자, 파일 소유 그룹, 
	파일 크기, 마지막 수정 날짜, 파일 이름

	- chown 명령어 : 파일 소유자 변경
	- chgrp 명령어 : 파일 소유 그룹 변경

	- 하드 링크/심벌릭 링크 차이점(ln ~ : 하드 링크, ls -s ~ : 심벌릭 링크)
	> 하드 링크는 원본 파일이 삭제되거나 위치가 바뀌어도 변함이 없지만, 심벌릭 링크는 원본 파일의 위치가 바뀌거나 삭제되면
	이상이 생긴다.

	- 프로세스
	> 포그라운드 프로세스 : 현재 화면에 나타나서 사용자와 상호 작용을 할 수 있는 프로세스
	> 백그라운드 프로세스 : 화면에 나타나지 않고 뒤에서 실행되는 프로세스(ex : 백신 프로그램)
	> 작업 번호 : 현재 실행 중인 백그라운드 프로세스의 순차 번호를 말함.
	> 프로세스 번호 : 프로세스를 구분하기 위해 부여한 고유 번호
	> 부모 프로세스와 자식 프로세스 : 부모/자식으로 연결되어 있는 프로세스도 있는데, 이 때 부모 프로세스를 종료하면 자식 프로세스도
	종료된다.

	- 프로세스 관련 명령어
	> ps : 현재 프로세스 상태 확인
	> pstree : 부모/자식 프로세스의 관계도를 트리 형태로 보여준다.
	> kill : 프로세스 종료

	- 서비스 = 데몬 = 서버 프로세스

	- 서비스는 평상시에도 작동하는 프로세스, 소켓은 필요할 때만 작동하는 프로세스이다.
	(소켓과 관련된 스크립트 파일은 /lib/systemd/system 안의 소켓.socket이다.)

	- /etc/passwd(사용자 등록되어 있음), /etc/group(그룹 등록되어 있음)

	- /etc/passwd의 구성
	사용자 이름, 비밀번호, 사용자 ID, 사용자 소속 그룹ID, 추가 정보, 홈 디렉터리, 기본 쉘

	- /etc/group의 구성
	그룹 이름, 비밀번호, 그룹 ID, 보조 그룹 사용자

	- 서비스의 시작, 중지, 재시작 명령어
	systemctl start/stop/restart

	- bash의 특징
	> 명령 단축(alias) 기능
	> 히스토리 기능
	> 연산 기능
	> Job Control 기능
	> 자동 이름 완성 기능(Tab)
	> 프롬프트 제어 기능
	> 명령 편집 기능



2. 학교 시험 대비(알고리즘)
	- 스택
		> 0개 이상의 원소를 갖는 유한 순서 리스트
		> 한쪽에서 삽입과 삭제 연산이 수행됨(push, pop 연산이 한 곳에서 발생)
		> 후입 선출 구조(LIFO : Last In First Out, 나중에 입력된 자료가 먼저 출력)
		> 위치를 가리키는 변수(top)의 초기값을 -1로 주고, Push가 발생하면 top 값을 1 증가시킨 후 데이터를 넣는다.
		(단, top 값이 스택의 마지막 위치면 더이상 Push 불가, 마찬가지로 top 값이 -1이면 Pop 연산 불가)


	- 큐
		> 작업 큐에 들어간 작업이 가장 처음에 처리되는 작업 스케줄(선입선출, FIFO : First In First Out)
		> 한 쪽에서는 삽입연산만, 다른 쪽에서는 삭제 연산만 할 수 있는 구조
		> 삽입 위치(rear) 변수와 삭제 위치(front) 변수를 선언하고, 초기값을 -1로 준다.
		> 스택과 비슷하게 삽입 혹은 삭제 연산 시 front나 rear 변수값을 1 증가시킨 후 해당 위치에 값을 삽입/삭제하는데,
		이 때 문제점은 삭제 연산을 해서 배열의 앞 공간에 데이터를 넣을 수 있는 공간이 생겼음에도 rear 변수값이 배열 길이의
		끝에 가 있으면 큐가 가득 찼다고 인식해 버린다는 것이다.
		(이를 잘못된 포화 상태라고 한다.)
		> 위 문제점 해결을 위해 원형 큐라는 개념이 나옴.
		(원형 큐는 rear 혹은 front의 값이 배열 길이를 넘어가면 나머지 연산자를 이용하여 다시 처음의 위치로 돌려 보낸다.
		이를 그림으로 그려 보면 원형으로 마지막과 처음이 이어져 있는 형태이기 때문에 원형 큐라고 불린다.)


	- 트리
		> 원소들 간 1:n 관계를 가지는 비선형 자료구조
		> 상위 원소에서 하위 원소로 내려가면서 확장되는 트리 모양의 구조이다.


	- 이진 트리
		> 트리의 모든 노드의 차수를 2 이하로 제한, 전체 트리의 차수가 2 이하가 되도록 정의함
		> 이진 트리의 모든 노드는 왼쪽/오른쪽 자식 노드만 가지게 된다.(공백 노드도 자식 노드로 취급)
		> 일반 트리를 이진 트리로 변환하는 방법
		첫 번째 자식 노드 간선만 남기고 나머지 간선 제거 -> 형제 노드를 간선으로 연결
		> 이진트리를 1차원 배열로 표현
		(0번째 위치는 비워 두고, 위치값 계산을 쉽게 하기 위해 1번 인덱스부터 데이터 삽입)
		(부모 노드의 인덱스값이 n이라면 왼쪽 자식노드 인덱스값은 2*n, 오른쪽 자식노드 인덱스값은 (2*n)+1 이 된다.)


	- 이진 트리의 순회
		> 모든 원소를 빠트리거나 중복하지 않고 처리하는 연산
		> 전위 순회, 중위 순회, 후위 순회 3 종류가 있다.
		(전위 순회 : 루트 > 왼쪽 > 오른쪽 노드, 중위 순회 : 왼쪽 > 루트 > 오른쪽 노드, 후위 순회 : 왼쪽 > 오른쪽 > 루트 노드 순으로 순회함)


	- 이진 탐색 트리
		> 이진 트리를 탐색용 자료구조로 사용하기 위해 원소 크기에 따라 노드 위치를 정의한 것
		> 특징
		1) 모든 원소는 서로 다른 유일한 키를 갖는다.
		2) 왼쪽 서브 트리에 있는 원소들의 키는 루트의 키보다 작다.
		3) 오른쪽 서브 트리에 있는 원소들의 키는 루트의 키보다 크다.
		4) 왼쪽/오른쪽 서브 트리도 이진 탐색 트리이다.


	- 이진 탐색 트리의 삭제 연산
		> 자식 노드가 없을 때에는 바로 삭제
		> 자식 노드가 1개 있을 때
		(해당 노드 삭제 후, 삭제된 노드의 자리를 자식 노드에게 물려준다.)
		> 자식 노드가 2개 있을 때
		(삭제 후 자식 노드들 중 후계자 선택, 후계자는 왼쪽 서브 트리에서 가장 큰 값 혹은 오른쪽 서브 트리에서 가장 작은 값으로 선택한다.)


	- 힙
		> 완전 이진 트리에 있는 노드 중 키값이 가장 큰 노드나 가장 작은 노드를 찾기 위해 만든 자료구조
		> 최대 힙(부모노드 키값>= 자식노드 키값), 최소 힙(부모노드 키값<=자식노드 키값)으로 나눠진다.
	

	- 그래프
		> 현상이나 사물을 정점과 간선으로 표현한 것(두 정점이 간선으로 연결되어 있으면 인접하다고 한다.)
		> 방향, 가중치로도 표현 가능


	- 그래프의 표현
		> 인접행렬
		N*N의 행렬로 표현, 해당 위치의 정점끼리 연결되어 있으면 1값을 넣고 아니면 0 값을 넣음(가중치 그래프면 해당 간선의 가중치값을 넣는다.)
		프로그램이 쉽지만 메모리 낭비가 심함
		> 인접리스트
		N개의 연결 리스트로 표현, i번째 리스트는 정점 i에 인접한 정점들을 리스트로 연결해 놓음
		메모리 낭비가 없지만 주소 관리 등 프로그램하기가 어려움
		> 인접배열
		N개의 연결 배열로 표현
		i번째 배열은 정점 i에 인접한 정점들을 집합(인접행렬과 인접리스트의 장점 취합한 형태)


	- 그래프에서 모든 정점 방문
		> 너비 우선 탐색(BFS : Breath First Search, 큐 사용)
		> 깊이 우선 탐색(DFS : Depth First Search, 스택 사용)
		

	- 탐욕 알고리즘
		> 동적 계획법과 마찬가지로 최적화 문제의 답을 얻기 위해 사용
		> 각 단계의 부분 문제를 풀 때 해당 단계에서의 최적화된 답을 찾는다.(전체적으로는 최적해를 구하지 못할 수 있다.)
		

	- 최소 신장 트리
		> 간선에 가중치 속성 부여, 각 간선이 갖고 있는 가중치의 합이 최소가 되는 신장 트리이다.
		> 무향 연결 그래프(방향X), 싸이클이 없음


	- 프림 알고리즘
		> 시작점 노드 선택 후, 현재 연결되어 있는 노드들 중 간선의 가중치값을 조사하여 가장 낮은 가중치값을 가진 간선으로
		새 노드 연결 후 최소 신장 트리에 포함

	
	- 크루스칼 알고리즘
		> 시작점X, 전체 그래프의 가중치로 오름차순으로 목록을 만들고, 차례대로 이 목록을 순회하며 최소 신장 트리에 추가
		(단, 추가된 간선으로 사이클이 생기면 안됨)
